-- 보호소에서 중성화한 동물
SELECT B.ANIMAL_ID AS ANIMAL_ID, B.ANIMAL_TYPE AS ANIMAL_TYPE, B.NAME AS NAME
FROM (SELECT *
      FROM ANIMAL_INS
      WHERE SEX_UPON_INTAKE LIKE '%INTACT%') A, ANIMAL_OUTS B
WHERE A.ANIMAL_ID = B.ANIMAL_ID AND B.SEX_UPON_OUTCOME NOT LIKE '%INTACT%'
ORDER BY 1 ASC

-- 입양 시각 구하기(2)
SET @hour = -1;
SELECT @hour := @hour + 1  AS HOUR, (
    SELECT COUNT(DATETIME)
    FROM ANIMAL_OUTS B
    WHERE HOUR(DATETIME) = @hour
) AS COUNT
FROM ANIMAL_OUTS A
WHERE @hour < 23

-- 우유와 요거트가 담긴 장바구니
SELECT CART_ID
FROM CART_PRODUCTS
WHERE NAME IN ( 'Yogurt', 'Milk' )
GROUP BY CART_ID
HAVING COUNT(DISTINCT NAME) = 2

-- 식품분류별 가장 비싼 식품의 정보 조회하기
SELECT CATEGORY, PRICE AS MAX_PRICE, PRODUCT_NAME
FROM FOOD_PRODUCT
WHERE (CATEGORY, PRICE) IN ( SELECT CATEGORY, MAX(PRICE)
                             FROM FOOD_PRODUCT
                             WHERE CATEGORY IN ('과자', '국', '김치', '식용유')
                             GROUP BY CATEGORY)
ORDER BY PRICE DESC

-- 5월 식품들의 총매출 조회하기
SELECT P.PRODUCT_ID, P.PRODUCT_NAME, SUM(P.PRICE * O.AMOUNT) AS TOTAL_PRICES
FROM FOOD_PRODUCT P INNER JOIN FOOD_ORDER O ON P.PRODUCT_ID = O.PRODUCT_ID
WHERE DATE_FORMAT(O.PRODUCE_DATE, '%Y-%m') = '2022-05'
GROUP BY PRODUCT_ID
ORDER BY TOTAL_PRICES DESC, P.PRODUCT_ID ASC;

-- 서울에 위치한 식당 목록  출력하기
SELECT R.REST_ID, I.REST_NAME, I.FOOD_TYPE, I.FAVORITES, I.ADDRESS, ROUND(AVG(R.REVIEW_SCORE),2) AS SCORE
FROM REST_REVIEW R JOIN REST_INFO I ON I.REST_ID = R.REST_ID
GROUP BY R.REST_ID
HAVING I.ADDRESS LIKE '서울%'
ORDER BY SCORE DESC, I.FAVORITES DESC

-- 그룹별 조건에 맞는 식당 목록 출력하기
SELECT M.MEMBER_NAME AS MEBER_NAME, R.REVIEW_TEXT AS REVIEW_TEXT, DATE_FORMAT(R.REVIEW_DATE, '%Y-%m-%d') AS REVIEW_DATE
FROM MEMBER_PROFILE M JOIN REST_REVIEW R ON M.MEMBER_ID = R.MEMBER_ID
WHERE M.MEMBER_ID = (SELECT MEMBER_ID FROM REST_REVIEW GROUP BY MEMBER_ID ORDER BY COUNT(*) DESC LIMIT 1)
ORDER BY REVIEW_DATE, REVIEW_TEXT

-- 년, 월, 성별 별 상품 구매 회원 수 구하기
SELECT DATE_FORMAT(O.SALES_DATE, '%Y') AS YEAR, DATE_FORMAT(O.SALES_DATE, '%m') MONTH, GENDER, COUNT(DISTINCT U.USER_ID) AS USERS
FROM USER_INFO U JOIN ONLINE_SALE O ON U.USER_ID = O.USER_ID
WHERE U.GENDER IS NOT NULL
GROUP BY YEAR, MONTH, GENDER
ORDER BY YEAR, MONTH, GENDER

-- 오프라인/온라인 판매 데이터 통합하기
SELECT DATE_FORMAT(A.SALES_DATE, "%Y-%m-%d") AS SALES_DATE, PRODUCT_ID, USER_ID, SALES_AMOUNT
FROM 
    (SELECT ONLINE_SALE_ID, USER_ID, PRODUCT_ID, SALES_AMOUNT, SALES_DATE  FROM ONLINE_SALE
    UNION ALL
    SELECT OFFLINE_SALE_ID, NULL, PRODUCT_ID, SALES_AMOUNT, SALES_DATE FROM OFFLINE_SALE) A
WHERE DATE_FORMAT(A.SALES_DATE, '%Y-%m') = '2022-03'
ORDER BY SALES_DATE, PRODUCT_ID, USER_ID;


-- 취소되지 않은 진료 예약 조회하기
SELECT A.APNT_NO AS APNT_NO, P.PT_NAME AS PT_NAME, P.PT_NO AS PT_NO, D.MCDP_CD AS MCDP_CD, D.DR_NAME AS DR_NAME, A.APNT_YMD AS APNT_YMD
FROM APPOINTMENT A 
JOIN PATIENT P ON A.PT_NO = P.PT_NO
JOIN DOCTOR D ON A.MDDR_ID = D.DR_ID
WHERE DATE_FORMAT(A.APNT_YMD, '%Y-%m-%d') = '2022-04-13' AND A.MCDP_CD ='CS' AND A.APNT_CNCL_YN ='N'
ORDER BY A.APNT_YMD

-- 주문량이 많은 아이스크림들 조회하기
SELECT F.FLAVOR
FROM FIRST_HALF F JOIN 
    (SELECT FLAVOR, SUM(TOTAL_ORDER) AS TOTAL_ORDER
    FROM JULY
    GROUP BY FLAVOR) J ON F.FLAVOR = J.FLAVOR
ORDER BY (F.TOTAL_ORDER+J.TOTAL_ORDER) DESC
LIMIT 3

-- 저자 별 카테고리 별 매출액 집계하기
SELECT A.AUTHOR_ID AS AUTHOR_ID, A.AUTHOR_NAME AS AUTHOR_NAME, B.CATEGORY AS CATEGORY, SUM(B.PRICE * S.SALES) AS TOTAL_SALES
FROM BOOK B
    JOIN AUTHOR A ON B.AUTHOR_ID = A.AUTHOR_ID
    JOIN BOOK_SALES S ON B.BOOK_ID = S.BOOK_ID
WHERE DATE_FORMAT(S.SALES_DATE, '%Y-%m') = '2022-01'
GROUP BY AUTHOR_ID, CATEGORY
ORDER BY AUTHOR_ID ASC, CATEGORY DESC

-- 자동차 대여 기록 별 대여 금액 구하기
WITH PLAN AS 
    (
        SELECT car_type, DISCOUNT_RATE, DURATION_TYPE
        FROM CAR_RENTAL_COMPANY_DISCOUNT_PLAN
        WHERE CAR_TYPE = '트럭'
    )

SELECT HISTORY_ID, ROUND(DURATION*DAILY_FEE*(100-COALESCE(DISCOUNT_RATE,0))/100) FEE
FROM (
    SELECT HISTORY_ID, DATEDIFF(END_DATE, START_DATE)+1 AS DURATION, DAILY_FEE, 
        CASE WHEN DATEDIFF(END_DATE, START_DATE)+1 >= 90 THEN (SELECT DISCOUNT_RATE FROM PLAN WHERE DURATION_TYPE = '90일 이상')
        WHEN DATEDIFF(END_DATE, START_DATE)+1 >= 30 THEN (SELECT DISCOUNT_RATE FROM PLAN WHERE DURATION_TYPE = '30일 이상')
        WHEN DATEDIFF(END_DATE, START_DATE)+1 >= 7 THEN (SELECT DISCOUNT_RATE FROM PLAN WHERE DURATION_TYPE = '7일 이상')
        END AS DISCOUNT_RATE
    FROM CAR_RENTAL_COMPANY_CAR C JOIN CAR_RENTAL_COMPANY_RENTAL_HISTORY H ON C.CAR_ID = H.CAR_ID
    WHERE C.CAR_TYPE = '트럭'
) SUB
ORDER BY FEE DESC, HISTORY_ID DESC

WITH INFO AS
    (
        SELECT HISTORY_ID, CAR_TYPE, DATEDIFF(END_DATE, START_DATE)+1 AS DAYS, DAILY_FEE, 
            CASE WHEN DATEDIFF(END_DATE, START_DATE)+1 >= 90 THEN '90일 이상'
                WHEN DATEDIFF(END_DATE, START_DATE)+1 >= 30 THEN '30일 이상'
                WHEN DATEDIFF(END_DATE, START_DATE)+1 >= 7 THEN '7일 이상'
            END AS DURATION_TYPE
        FROM CAR_RENTAL_COMPANY_CAR C JOIN CAR_RENTAL_COMPANY_RENTAL_HISTORY H ON C.CAR_ID = H.CAR_ID
        WHERE C.CAR_TYPE = '트럭'
    )

SELECT I.HISTORY_ID, ROUND(DAYS * DAILY_FEE*(100-COALESCE(P.DISCOUNT_RATE,0))/100) AS FEE
FROM INFO I LEFT JOIN CAR_RENTAL_COMPANY_DISCOUNT_PLAN P ON I.CAR_TYPE=P.CAR_TYPE AND I.DURATION_TYPE = P.DURATION_TYPE
ORDER BY FEE DESC, HISTORY_ID DESC;


-- 특정 기간동안 대여 가능한 자동차들의 대여비용 구하기
SELECT C.CAR_ID, C.CAR_TYPE, ROUND(DAILY_FEE * 30 * (100-P.DISCOUNT_RATE)/100) AS FEE
FROM CAR_RENTAL_COMPANY_CAR C
    JOIN CAR_RENTAL_COMPANY_DISCOUNT_PLAN P ON C.CAR_TYPE = P.CAR_TYPE
WHERE C.CAR_TYPE IN ('세단', 'SUV') AND P.DURATION_TYPE='30일 이상'
    AND C.CAR_ID NOT IN (SELECT CAR_ID FROM CAR_RENTAL_COMPANY_RENTAL_HISTORY WHERE START_DATE <= '2022-11-30' AND END_DATE >= '2022-11-01')
HAVING FEE >= 500000 AND FEE < 2000000 
ORDER BY FEE DESC, CAR_TYPE ASC, CAR_ID DESC